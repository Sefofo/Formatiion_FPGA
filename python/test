
`timescale 1 ns / 10 ps

module wrp #(
    parameter START          = 32'h0000_0000,
    parameter END_            = 32'h0000_0000

) (
    // Horloge et reset
    input  logic  clk,
    input  logic  reset,

    // Signaux de synchro
	input logic              syn,

    
    // interfaces x_m 
    itf_x_m.sl             x_m,
    input logic [31:0]       cpt
    


);


//----------------------------------------------------------------------------------

// SIGNAUX INTERNES

//----------------------------------------------------------------------------------

logic [31:0]    datat;

//----------------------------------------------------------------------------------

// LECTURE des aleas via le crossbar

//----------------------------------------------------------------------------------

assign x_m.xt_ack = x_m.xt_vld;

always @(posedge reset or posedge clk)

begin
	if  (reset)
	begin
		x_m.xs_vld  <= 1'b0;
		x_m.xs_addr <= 5'h00;
		x_m.xs_data <= 32'h0000_0000;
	end

	else

	begin
		x_m.xs_vld  <= 1'b0;
		x_m.xs_addr <= 5'h00;
		x_m.xs_data <= 32'h0000_0000;
		if (x_m.xt_vld & x_m_rng.xt_rd_nwr & xt_rand.vld)  //

		begin
			x_m.xs_vld  <= 1'b1;
			x_m.xs_addr <= x_m.xt_addr;
			
			case (x_m.xt_addr[4:0])
			
				5'd0    : x_m.xs_data 	   <= P_START_TAG;
				5'd1    : x_m.xs_data 	   <= datation;
				5'd2    : x_m.xs_data        <= xt_rand.payload;
				5'd3    : x_m.xs_data 	   <= xt_rand.payload;
				5'd4    : x_m.xs_data        <= xt_rand.payload;
				5'd5    : x_m.xs_data        <= xt_rand.payload;
				5'd6    : x_m.xs_data        <= xt_rand.payload;
				5'd7    : x_m.xs_data        <= xt_rand.payload;
				5'd8    : x_m.xs_data 	   <= P_END_TAG;
				default : x_m.xs_data 	   <= 32'h0000_0000;
			endcase
		end
	end
end



always @(posedge reset or posedge clk)
begin
	if (reset) begin
		datat <= 32'b0;
	end
	else begin
		if(syn)
			datat <= cpt;
	end
end

//----------------------------------------------------------------------------------

    // Interfaces

//----------------------------------------------------------------------------------

    // interface xt_rand
    itf_xt_gen#(
        .PAYLOAD_MASTER (logic [WIDTH-1:0]),
        .PAYLOAD_SLAVE  (logic)
    ) xt_rand (
        .clk            (clk),
        .reset          (~reset_n)
    );

	
//----------------------------------------------------------------------------------

    // Instanciation acc_rng_osc

//----------------------------------------------------------------------------------

    acc_rng_osc #(
        .USE_RAM                 (0),
        .DEPTH                   (1),
        .WIDTH                   ('d32)
    )
    acc_rng_osc_0 (
        .clk                     (clk),
        .reset_n                 (reset_n),
        .power_on                (power_on),
        .enable                  (enable),
        .enable_gen              (enable_gen),
        .kd_value                (kd_value),
        .xt_rand                 (xt_rand)
    ); 



endmodule : wrp

-------------------------------------------------------------------------------------------------------------

// Spécifie l'échelle de temps
timescale 1 ns / 10 ps

// Définition du module "wrp" avec des paramètres par défaut
module wrp #(
    parameter START = 32'h0000_0000,
    parameter END_   = 32'h0000_0000
) (
    // Entrées : Horloge, reset, signal de synchronisation, interfaces
    input  logic  clk,
    input  logic  reset,
    input  logic  syn,
    itf_x_m.sl   x_m,
    input  logic [31:0] cpt
);

// Signaux internes
logic [31:0] datat;

// Assignation conditionnelle pour signaler la validité à l'interface de sortie
assign x_m.xt_ack = x_m.xt_vld;

// Bloc always déclenche au front montant de la réinitialisation ou de l'horloge
always @(posedge reset or posedge clk)
begin
    if (reset)
    begin
        x_m.xs_vld  <= 1'b0;
        x_m.xs_addr <= 5'h00;
        x_m.xs_data <= 32'h0000_0000;
    end
    else
    begin
        // Bloc de traitement en fonction des conditions
        // ...
    end
end

// Bloc always pour la gestion du signal interne "datat"
always @(posedge reset or posedge clk)
begin
    if (reset)
    begin
        datat <= 32'b0;
    end
    else
    begin
        // Affectation de "cpt" à "datat" lorsqu'un signal de synchronisation est actif
        if(syn)
            datat <= cpt;
    end
end

// Interface "xt_rand" instanciée avec les paramètres spécifiés
itf_xt_gen#(
    .PAYLOAD_MASTER (logic [WIDTH-1:0]),
    .PAYLOAD_SLAVE  (logic)
) xt_rand (
    .clk   (clk),
    .reset (~reset_n)
);

// Instance du module "acc_rng_osc" avec des paramètres spécifiés
acc_rng_osc #(
    .USE_RAM (0),
    .DEPTH   (1),
    .WIDTH   ('d32)
) acc_rng_osc_0 (
    .clk        (clk),
    .reset_n    (reset_n),
    .power_on   (power_on),
    .enable     (enable),
    .enable_gen (enable_gen),
    .kd_value   (kd_value),
    .xt_rand    (xt_rand)
);

// Fin du module "wrp"
endmodule : wrp





D'accord, examinons la partie du code relative à la machine à états `case` :

```verilog
// Bloc always déclenche au front montant de la réinitialisation ou de l'horloge
always @(posedge reset or posedge clk)
begin
    if (reset)
    begin
        x_m.xs_vld  <= 1'b0;
        x_m.xs_addr <= 5'h00;
        x_m.xs_data <= 32'h0000_0000;
    end
    else
    begin
        // Si les signaux spécifiques sont valides
        if (x_m.xt_vld & x_m_rng.xt_rd_nwr & xt_rand.vld)
        begin
            // Active le signal de validité de sortie
            x_m.xs_vld  <= 1'b1;
            // Affecte l'adresse de sortie à partir de l'adresse d'entrée
            x_m.xs_addr <= x_m.xt_addr;
            
            // Case statement basée sur les bits 4:0 de l'adresse
            case (x_m.xt_addr[4:0])
                5'd0 : x_m.xs_data <= P_START_TAG;
                5'd1 : x_m.xs_data <= datation;
                5'd2 : x_m.xs_data <= xt_rand.payload;
                5'd3 : x_m.xs_data <= xt_rand.payload;
                5'd4 : x_m.xs_data <= xt_rand.payload;
                5'd5 : x_m.xs_data <= xt_rand.payload;
                5'd6 : x_m.xs_data <= xt_rand.payload;
                5'd7 : x_m.xs_data <= xt_rand.payload;
                5'd8 : x_m.xs_data <= P_END_TAG;
                default : x_m.xs_data <= 32'h0000_0000;
            endcase
        end
    end
end
```
----------------------------------------------------------------------------------------------------

// Bloc always déclenche au front montant de la réinitialisation ou de l'horloge
always @(posedge reset or posedge clk)
begin
    if (reset)
    begin
        x_m.xs_vld  <= 1'b0;
        x_m.xs_addr <= 5'h00;
        x_m.xs_data <= 32'h0000_0000;
    end
    else
    begin
        // Si les signaux spécifiques sont valides
        if (x_m.xt_vld & x_m_rng.xt_rd_nwr & xt_rand.vld)
        begin
            // Active le signal de validité de sortie
            x_m.xs_vld  <= 1'b1;
            // Affecte l'adresse de sortie à partir de l'adresse d'entrée
            x_m.xs_addr <= x_m.xt_addr;
            
            // Case statement basée sur les bits 4:0 de l'adresse
            case (x_m.xt_addr[4:0])
                5'd0 : x_m.xs_data <= P_START_TAG;
                5'd1 : x_m.xs_data <= datation;
                5'd2 : x_m.xs_data <= xt_rand.payload;
                5'd3 : x_m.xs_data <= xt_rand.payload;
                5'd4 : x_m.xs_data <= xt_rand.payload;
                5'd5 : x_m.xs_data <= xt_rand.payload;
                5'd6 : x_m.xs_data <= xt_rand.payload;
                5'd7 : x_m.xs_data <= xt_rand.payload;
                5'd8 : x_m.xs_data <= P_END_TAG;
                default : x_m.xs_data <= 32'h0000_0000;
            endcase
        end
    end
end



Explications ligne par ligne :

- Le bloc `always` est déclenché au front montant de la réinitialisation ou de l'horloge.
- Si `reset` est actif, les signaux de sortie (`x_m.xs_vld`, `x_m.xs_addr`, `x_m.xs_data`) sont réinitialisés.
- Sinon, si les signaux spécifiques sont valides (`x_m.xt_vld`, `x_m_rng.xt_rd_nwr`, `xt_rand.vld`), la machine à états est activée.
- La sortie `x_m.xs_vld` est activée, l'adresse de sortie est configurée à partir de l'adresse d'entrée, et la sortie de données est déterminée en fonction des bits 4:0 de l'adresse d'entrée.
- La sortie de données dépend du cas (case) spécifié par les bits 4:0 de l'adresse d'entrée.
- Si l'adresse d'entrée correspond à un cas non spécifié, la sortie de données est réinitialisée à `32'h0000_0000`.
  
Cette partie du code gère la logique de la machine à états basée sur une adresse d'entrée spécifique.
-----------------------------------------------------------------------------------------------------------
// Bloc always déclenché au front montant de la réinitialisation ou de l'horloge
always @(posedge reset or posedge clk)
begin
    if (reset)
    begin
        // Initialisation des signaux en cas de réinitialisation
        x_m.xs_vld  <= 1'b0;
        x_m.xs_addr <= 5'h00;
        x_m.xs_data <= 32'h0000_0000;
    end
    else
    begin
        // Réinitialisation des signaux à des valeurs par défaut
        x_m.xs_vld  <= 1'b0;
        x_m.xs_addr <= 5'h00;
        x_m.xs_data <= 32'h0000_0000;

        // Vérification de certaines conditions pour activer la machine à état
        if (x_m.xt_vld & x_m_rng.xt_rd_nwr & xt_rand.vld)
        begin
            // Activation de la machine à état
            x_m.xs_vld  <= 1'b1;
            x_m.xs_addr <= x_m.xt_addr;
            
            // Case basée sur les bits 4:0 de l'adresse x_m.xt_addr
            case (x_m.xt_addr[4:0])
                5'd0    : x_m.xs_data <= P_START_TAG;
                5'd1    : x_m.xs_data <= datation;
                5'd2    : x_m.xs_data <= xt_rand.payload;
                5'd3    : x_m.xs_data <= xt_rand.payload;
                5'd4    : x_m.xs_data <= xt_rand.payload;
                5'd5    : x_m.xs_data <= xt_rand.payload;
                5'd6    : x_m.xs_data <= xt_rand.payload;
                5'd7    : x_m.xs_data <= xt_rand.payload;
                5'd8    : x_m.xs_data <= P_END_TAG;
                default : x_m.xs_data <= 32'h0000_0000;
            endcase
        end
    end
end
Explications ligne par ligne :

Le bloc always est déclenché au front montant de la réinitialisation (reset) ou de l'horloge (clk).
Si le signal de réinitialisation (reset) est actif, les signaux de sortie sont initialisés à des valeurs par défaut.
Sinon, le bloc vérifie certaines conditions avant d'activer la machine à état.
Si les conditions sont remplies, la machine à état est activée (x_m.xs_vld mis à 1) et l'adresse de sortie (x_m.xs_addr) est mise à jour en fonction de l'adresse d'entrée (x_m.xt_addr).
La machine à état utilise un case pour déterminer la valeur de sortie (x_m.xs_data) en fonction des bits 4:0 de l'adresse d'entrée.
Si aucune condition n'est satisfaite, la valeur de sortie est initialisée à une valeur par défaut.
----------------------------------------------------------------------------------------------

paintext
              +-------------------------------------+
              |                                     |
              v                                     |
      +---------------+                               |
      |               |                               |
      |   Etat initial|                               |
      |               |                               |
      +---------------+                               |
              |                                       |
              |                                       |
              |                                       |
              v                                       |
      +---------------+         +---------------------|---------------------+
      |               |         |                     v                     |
      |    Etat 0     |---------|                  +------+                 |
      |               |         |                  |      |                 |
      +---------------+         |                  | Etat |                 |
              |                 |                  |   1  |                 |
              |                 |                  |      |                 |
              v                 |                  +------+                 |
      +---------------+         |                           ^                 |
      |               |         |                           |                 |
      |    Etat 2     |---------|                           |                 |
      |               |         |                           |                 |
      +---------------+         |                           |                 |
              |                 |                           |                 |
              |                 |                           |                 |
              v                 |                           |                 |
      +---------------+         |                           |                 |
      |               |         |                           |                 |
      |    Etat 3     |---------|                           |                 |
      |               |         |                           |                 |
      +---------------+         |                           |                 |
              |                 |                           |                 |
              |                 |                           |                 |
              v                 |                           |                 |
      +---------------+         |                           |                 |
      |               |         |                           |                 |
      |    Etat 4     |---------|                           |                 |
      |               |         |                           |                 |
      +---------------+         |                           |                 |
              |                 |                           |                 |
              |                 |                           |                 |
              v                 |                           |                 |
      +---------------+         |                           |                 |
      |               |         |                           |                 |
      |    Etat 5     |---------|                           |                 |
      |               |         |                           |                 |
      +---------------+         |                           |                 |
              |                 |                           |                 |
              |                 |                           |                 |
              v                 |                           |                 |
      +---------------+         |                           |                 |
      |               |         |                           |                 |
      |    Etat 6     |---------|                           |                 |
      |               |         |                           |                 |
      +---------------+         |                           |                 |
              |                 |                           |                 |
              |                 |                           |                 |
              v                 |                           |                 |
      +---------------+         |                           |                 |
      |               |         |                           |                 |
      |    Etat 7     |---------|                           |                 |
      |               |         |                           |                 |
      +---------------+         |                           |                 |
              |                 |                           |                 |
              |                 |                           |                 |
              v                 |                           |                 |
      +---------------+         |                           |                 |
      |               |         |                           |                 |
      |    Etat 8     |---------|                           |                 |
      |               |                                     |                 |
      +---------------+                                     |                 |
              ^                                               |                 |
              |                                               |                 |
              +-----------------------------------------------|-----------------+
                                                              |
                                                              |
                                                              v
                                                        +---------------+
                                                        |               |
                                                        | Etat final    |
                                                        |               |
                                                        +---------------+
-----------------------------------------------------------------------
testben
Pour créer un testbench pour votre module VHDL, vous pouvez suivre les étapes suivantes. Assurez-vous d'ajuster les paramètres en fonction de votre conception et de spécifier les valeurs d'entrée nécessaires pour tester différents scénarios.

```verilog
`timescale 1 ns / 10 ps

module testbench;

    // Déclaration des signaux du testbench
    reg clk;
    reg reset;
    reg syn;
    reg [31:0] cpt;

    // Déclaration des signaux d'interface x_m
    reg [31:0] x_m_xt_addr;
    reg x_m_xt_vld;
    reg [31:0] x_m_xt_data;
    wire x_m_xs_vld;
    wire [4:0] x_m_xs_addr;
    wire [31:0] x_m_xs_data;

    // Instanciation du module
    wrp #(
        .START(32'h0000_0000),
        .END_(32'h0000_0000)
    ) dut (
        .clk(clk),
        .reset(reset),
        .syn(syn),
        .x_m({x_m_xt_vld, x_m_xt_addr, x_m_xt_data, x_m_xs_vld, x_m_xs_addr, x_m_xs_data}),
        .cpt(cpt)
    );

    // Génération de l'horloge
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // Initialisation des signaux
    initial begin
        reset = 1;
        syn = 0;
        cpt = 0;
        // Initialisez d'autres signaux d'entrée si nécessaire

        // Simulation du comportement de votre module
        // Ajoutez ici des instructions pour modifier les signaux d'entrée au fil du temps
        #10 reset = 0;
        #10 syn = 1;
        #1000 $finish;
    end

    // Génération des impulsions x_m_xt_vld et x_m_xt_data
    always #5 x_m_xt_vld = ~x_m_xt_vld;

    // Simulation des transactions x_m_xt_data
    always @(posedge clk) begin
        if (x_m_xt_vld) begin
            case (x_m_xt_addr)
                5'd0 : x_m_xt_data = 32'h01234567; // Exemple de données pour l'adresse 0
                5'd1 : x_m_xt_data = 32'h89ABCDEF; // Exemple de données pour l'adresse 1
                // Ajoutez d'autres cas pour les différentes adresses
                default : x_m_xt_data = 32'h00000000;
            endcase
        end
    end

    // Affichage des résultats
    initial begin
        $monitor("Time=%0t clk=%b reset=%b syn=%b x_m_xt_vld=%b x_m_xt_addr=%h x_m_xt_data=%h x_m_xs_vld=%b x_m_xs_addr=%h x_m_xs_data=%h",
            $time, clk, reset, syn, x_m_xt_vld, x_m_xt_addr, x_m_xt_data, x_m_xs_vld, x_m_xs_addr, x_m_xs_data);
    end

endmodule : testbench
```

Ce testbench initialise les signaux, génère une horloge, simule le comportement de votre module en modifiant les signaux d'entrée au fil du temps, et affiche les résultats de la simulation. N'oubliez pas de personnaliser les données d'adresse et de tester différentes conditions pour vous assurer que votre module fonctionne correctement.


-------------------------------------------
Je m'excuse pour la confusion. Voici un exemple de testbench écrit en Verilog pour le module que vous avez fourni :

```verilog
`timescale 1 ns / 10 ps

module tb_wrp;

    // Déclaration des signaux du testbench
    reg clk;
    reg reset;
    reg syn;
    reg [31:0] cpt;

    // Déclaration des signaux d'interface x_m
    reg [31:0] x_m_xt_addr;
    reg x_m_xt_vld;
    reg [31:0] x_m_xt_data;
    wire x_m_xs_vld;
    wire [4:0] x_m_xs_addr;
    wire [31:0] x_m_xs_data;

    // Instanciation du module
    wrp #(
        .START(32'h0000_0000),
        .END_(32'h0000_0000)
    ) dut (
        .clk(clk),
        .reset(reset),
        .syn(syn),
        .x_m({x_m_xt_vld, x_m_xt_addr, x_m_xt_data, x_m_xs_vld, x_m_xs_addr, x_m_xs_data}),
        .cpt(cpt)
    );

    // Génération de l'horloge
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // Initialisation des signaux
    initial begin
        reset = 1;
        syn = 0;
        cpt = 0;
        // Initialisez d'autres signaux d'entrée si nécessaire

        // Simulation du comportement de votre module
        // Ajoutez ici des instructions pour modifier les signaux d'entrée au fil du temps
        #10 reset = 0;
        #10 syn = 1;
        #1000 $finish;
    end

    // Génération des impulsions x_m_xt_vld et x_m_xt_data
    always #5 x_m_xt_vld = ~x_m_xt_vld;

    // Simulation des transactions x_m_xt_data
    always @(posedge clk) begin
        if (x_m_xt_vld) begin
            case (x_m_xt_addr)
                5'd0 : x_m_xt_data = 32'h01234567; // Exemple de données pour l'adresse 0
                5'd1 : x_m_xt_data = 32'h89ABCDEF; // Exemple de données pour l'adresse 1
                // Ajoutez d'autres cas pour les différentes adresses
                default : x_m_xt_data = 32'h00000000;
            endcase
        end
    end

    // Affichage des résultats
    initial begin
        $monitor("Time=%0t clk=%b reset=%b syn=%b x_m_xt_vld=%b x_m_xt_addr=%h x_m_xt_data=%h x_m_xs_vld=%b x_m_xs_addr=%h x_m_xs_data=%h",
            $time, clk, reset, syn, x_m_xt_vld, x_m_xt_addr, x_m_xt_data, x_m_xs_vld, x_m_xs_addr, x_m_xs_data);
    end

endmodule : tb_wrp
```

Ce testbench initialise les signaux, génère une horloge, simule le comportement de votre module en modifiant les signaux d'entrée au fil du temps, et affiche les résultats de la simulation. N'oubliez pas de personnaliser les données d'adresse et de tester différentes conditions pour vous assurer que votre module fonctionne correctement.
